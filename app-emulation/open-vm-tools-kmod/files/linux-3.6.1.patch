diff -urpN a/modules/linux/vmblock/linux/dentry.c b/modules/linux/vmblock/linux/dentry.c
--- a/modules/linux/vmblock/linux/dentry.c	2012-08-01 19:03:37.000000000 -0700
+++ b/modules/linux/vmblock/linux/dentry.c	2012-10-14 07:22:36.000000000 -0700
@@ -32,7 +32,11 @@
 #include "block.h"
 
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+static int DentryOpRevalidate(struct dentry *dentry, unsigned int flags);
+#else
 static int DentryOpRevalidate(struct dentry *dentry, struct nameidata *nd);
+#endif
 
 struct dentry_operations LinkDentryOps = {
    .d_revalidate = DentryOpRevalidate,
@@ -60,7 +64,11 @@ struct dentry_operations LinkDentryOps =
 
 static int
 DentryOpRevalidate(struct dentry *dentry,  // IN: dentry revalidating
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+		   unsigned int flags)
+#else
                    struct nameidata *nd)   // IN: lookup flags & intent
+#endif
 {
    VMBlockInodeInfo *iinfo;
    struct nameidata actualNd;
@@ -101,7 +109,11 @@ DentryOpRevalidate(struct dentry *dentry
    if (actualDentry &&
        actualDentry->d_op &&
        actualDentry->d_op->d_revalidate) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+      return actualDentry->d_op->d_revalidate(actualDentry, flags);
+#else
       return actualDentry->d_op->d_revalidate(actualDentry, nd);
+#endif
    }
 
    if (compat_path_lookup(iinfo->name, 0, &actualNd)) {
diff -urpN a/modules/linux/vmblock/linux/inode.c b/modules/linux/vmblock/linux/inode.c
--- a/modules/linux/vmblock/linux/inode.c	2012-08-01 19:03:37.000000000 -0700
+++ b/modules/linux/vmblock/linux/inode.c	2012-10-14 07:18:00.000000000 -0700
@@ -35,8 +35,13 @@
 
 
 /* Inode operations */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+static struct dentry *InodeOpLookup(struct inode *dir,
+                                    struct dentry *dentry, unsigned int flags);
+#else
 static struct dentry *InodeOpLookup(struct inode *dir,
                                     struct dentry *dentry, struct nameidata *nd);
+#endif
 static int InodeOpReadlink(struct dentry *dentry, char __user *buffer, int buflen);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 13)
 static void *InodeOpFollowlink(struct dentry *dentry, struct nameidata *nd);
@@ -75,7 +80,11 @@ static struct inode_operations LinkInode
 static struct dentry *
 InodeOpLookup(struct inode *dir,      // IN: parent directory's inode
               struct dentry *dentry,  // IN: dentry to lookup
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+	      unsigned int flags)
+#else
               struct nameidata *nd)   // IN: lookup intent and information
+#endif
 {
    char *filename;
    struct inode *inode;
diff -urpN a/modules/linux/vmsync/sync.c b/modules/linux/vmsync/sync.c
--- a/modules/linux/vmsync/sync.c	2012-08-01 19:02:59.000000000 -0700
+++ b/modules/linux/vmsync/sync.c	2012-10-14 07:38:18.000000000 -0700
@@ -162,7 +162,11 @@ VmSyncThawDevices(void  *_state)  // IN
    cancel_delayed_work(&state->thawTask);
    list_for_each_safe(cur, tmp, &state->devices) {
       dev = list_entry(cur, VmSyncBlockDevice, list);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+      if (dev->sb != NULL && dev->sb->s_writers.frozen != SB_UNFROZEN) {
+#else
       if (dev->sb != NULL && dev->sb->s_frozen != SB_UNFROZEN) {
+#endif
          thaw_bdev(dev->bdev, dev->sb);
          atomic_dec(&gFreezeCount);
       }
@@ -237,7 +241,11 @@ VmSyncAddPath(const VmSyncState *state,
     * the superblock is already frozen.
     */
    if (inode->i_sb->s_bdev == NULL ||
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+       inode->i_sb->s_writers.frozen != SB_UNFROZEN) {
+#else
        inode->i_sb->s_frozen != SB_UNFROZEN) {
+#endif
       result = (inode->i_sb->s_bdev == NULL) ? -EINVAL : -EALREADY;
       compat_path_release(&nd);
       goto exit;
diff -urpN a/modules/linux/vmhgfs/dentry.c b/modules/linux/vmhgfs/dentry.c
--- a/modules/linux/vmhgfs/dentry.c	2012-08-01 19:02:48.000000000 -0700
+++ b/modules/linux/vmhgfs/dentry.c	2012-10-14 13:48:56.000000000 -0700
@@ -36,7 +36,11 @@
 
 /* HGFS dentry operations. */
 static int HgfsDentryRevalidate(struct dentry *dentry,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+				unsigned int flags);
+#else
                                 struct nameidata *nd);
+#endif
 
 /* HGFS dentry operations structure. */
 struct dentry_operations HgfsDentryOperations = {
@@ -71,7 +75,11 @@ struct dentry_operations HgfsDentryOpera
 
 static int
 HgfsDentryRevalidate(struct dentry *dentry,  // IN: Dentry to revalidate
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+		     unsigned int flags)
+#else
                      struct nameidata *nd)   // IN: Lookup flags & intent
+#endif
 {
    int error;
    LOG(6, (KERN_DEBUG "VMware hgfs: HgfsDentryRevalidate: calling "
@@ -80,7 +88,11 @@ HgfsDentryRevalidate(struct dentry *dent
    ASSERT(dentry);
 
 #if defined(LOOKUP_RCU) /* Introduced in 2.6.38 */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+   if (flags & LOOKUP_RCU) {
+#else
    if (nd && (nd->flags & LOOKUP_RCU)) {
+#endif
       return -ECHILD;
    }
 #endif
diff -urpN a/modules/linux/vmhgfs/inode.c b/modules/linux/vmhgfs/inode.c
--- a/modules/linux/vmhgfs/inode.c	2012-08-01 19:02:48.000000000 -0700
+++ b/modules/linux/vmhgfs/inode.c	2012-10-14 13:41:47.000000000 -0700
@@ -75,10 +75,18 @@ static int HgfsPackSymlinkCreateRequest(
 static int HgfsCreate(struct inode *dir,
                       struct dentry *dentry,
                       compat_umode_t mode,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+		      bool excl);
+#else
                       struct nameidata *nd);
+#endif
 static struct dentry *HgfsLookup(struct inode *dir,
                                  struct dentry *dentry,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+				 unsigned int flags);
+#else
                                  struct nameidata *nd);
+#endif
 static int HgfsMkdir(struct inode *dir,
                      struct dentry *dentry,
                      compat_umode_t mode);
@@ -952,7 +960,11 @@ static int
 HgfsCreate(struct inode *dir,     // IN: Parent dir to create in
            struct dentry *dentry, // IN: Dentry containing name to create
            compat_umode_t mode,   // IN: Mode of file to be created
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+	   bool excl)
+#else
 	   struct nameidata *nd)  // IN: Intent, vfsmount, ...
+#endif
 {
    HgfsAttrInfo attr;
    int result;
@@ -1025,7 +1037,11 @@ HgfsCreate(struct inode *dir,     // IN:
 static struct dentry *
 HgfsLookup(struct inode *dir,      // IN: Inode of parent directory
            struct dentry *dentry,  // IN: Dentry containing name to look up
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+	   unsigned int flags)
+#else
            struct nameidata *nd)   // IN: Intent, vfsmount, ...
+#endif
 {
    HgfsAttrInfo attr;
    struct inode *inode;
@@ -1801,7 +1817,11 @@ HgfsPermission(struct inode *inode,
 #else
    if (mask & MAY_ACCESS) { /* For sys_access. */
 #endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+      struct hlist_node *p;
+#else
       struct list_head *pos;
+#endif
       int dcount = 0;
       struct dentry *dentry = NULL;
 
@@ -1817,8 +1837,12 @@ HgfsPermission(struct inode *inode,
 #endif
 
       /* Find a dentry with valid d_count. Refer bug 587789. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+      hlist_for_each_entry(dentry, p, &inode->i_dentry, d_alias) {
+#else
       list_for_each(pos, &inode->i_dentry) {
          dentry = list_entry(pos, struct dentry, d_alias);
+#endif
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 38)
          dcount = atomic_read(&dentry->d_count);
 #else
diff -urpN a/modules/linux/vmhgfs/page.c b/modules/linux/vmhgfs/page.c
--- a/modules/linux/vmhgfs/page.c	2012-08-01 19:02:48.000000000 -0700
+++ b/modules/linux/vmhgfs/page.c	2012-10-14 07:49:37.000000000 -0700
@@ -893,7 +893,11 @@ HgfsDoWriteBegin(struct page *page,
     */
    if ((offset >= currentFileSize) ||
        ((pageFrom == 0) && (offset + pageTo) >= currentFileSize)) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+      void *kaddr = kmap_atomic(page);
+#else
       void *kaddr = kmap_atomic(page, KM_USER0);
+#endif
 
       if (pageFrom) {
          memset(kaddr, 0, pageFrom);
@@ -901,7 +905,11 @@ HgfsDoWriteBegin(struct page *page,
       if (pageTo < PAGE_CACHE_SIZE) {
          memset(kaddr + pageTo, 0, PAGE_CACHE_SIZE - pageTo);
       }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+      kunmap_atomic(kaddr);
+#else
       kunmap_atomic(kaddr, KM_USER0);
+#endif
       flush_dcache_page(page);
    }
 }
